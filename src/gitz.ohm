Gitz {
  Program = Statement+

  // Statements
  Statement =
      VarDecl
    | ListDecl
    | FunDecl
    | Assignment
    | FunCall
    | ReturnStmt
    | IfStmt
    | LoopStmt
    | TryStmt
    | BreakStmt
    | ContinueStmt
    | SayStmt

  // Print Statement
  SayStmt = "say" "(" ListOf<Exp, ","> ")" ";"

  // Variable & List Declarations
  VarDecl = "Make" id ":" (BasicType | ListType) Initialiser ";"
  ListDecl = "Make" id ":" ListType Initialiser ";"

  // Initialization (JavaScript-like)
  Initialiser = "=" AssignmentExpression

  // Function Declaration
  FunDecl = "Show" id Params ("->" Type)? Block
  Params = "(" ListOf<Param, ","> ")"
  Param = id ":" Type

  // Return Statement (Allow optional `;`)
  ReturnStmt = "give" Exp (";" | end)

  // If Statement
  IfStmt = "When" Exp Block ("orWhen" Exp Block)* ("orElse" Block)?

  // Loop Statements
  LoopStmt = "Keep" id "in" Exp Block --forEach
           | "Keep" Exp Block          --whileLoop

  // Break & Continue (for loop control)
  BreakStmt = "Break" ";"
  ContinueStmt = "Skip" ";"

  // Assignments
  Assignment = id "=" AssignmentExpression ";"

  // Function Calls
  FunCall = id "(" ListOf<Exp, ","> ")"

  // Try-Catch Blocks
  TryStmt = "Try" Block "Catch" id Block

  // Code Blocks
  Block = "{" Statement* "}"

  // Expressions
  Exp = AssignmentExpression  --standardExp
  AssignmentExpression = EqualityExpression
  EqualityExpression = RelationalExpression ("equal" RelationalExpression | "notSame" RelationalExpression)?
  RelationalExpression = AdditiveExpression ("bigger" AdditiveExpression | "smaller" AdditiveExpression | "in" AdditiveExpression)? 
  AdditiveExpression = MultiplicativeExpression ("plus" MultiplicativeExpression | "minus" MultiplicativeExpression)?
  MultiplicativeExpression = UnaryExpression ("times" UnaryExpression | "over" UnaryExpression | "mod" UnaryExpression)?

  // **Fixed UnaryExpression**
  UnaryExpression = "not" PrimaryExpression  --negate
                  | PrimaryExpression

  // **Fixed PrimaryExpression (Allows Function Calls)**
  PrimaryExpression = "(" Exp ")"  --parens
                    | FunCall      --functionCall
                    | id           --identifier
                    | IntLit       --integer
                    | FloatLit     --float
                    | StringLit    --string
                    | ListExp      --list

  // Data Types
  Type = BasicType | ListType
  BasicType = "num" | "text" | "bool" | id
  ListType = "list" "[" Type "]" | "list" "<" Type ">"

  // Identifiers (ensures they do not match keywords)
  id = ~keyword letter alnum*

  // Literals
  IntLit = digit+
  FloatLit = digit+ "." digit+ ("E" ("+" | "-")? digit+)?
  StringLit = "\"" Char* "\""
  ListExp = "[" ListOf<(StringLit | Exp), ",">? "]"

  // Characters inside string literals
  Char = NormalChar | EscapeSeq | unicodeEscape
  NormalChar = ~Control ~"\\" ~"\"" any
  EscapeSeq = "\\" ("n" | "t" | "\"" | "\\")
  unicodeEscape = "\\u{" hexDigit+ "}"
  
  Control = "\x00".."\x1f" | "\x80".."\x9f"

  // Keywords (ensuring reserved words are excluded from id)
  keyword = "Make" | "list" | "Show" | "When" | "Keep" | "orWhen" | "orElse" 
          | "give" | "say" | "Break" | "Skip" | "Try" | "Catch" | "in"

  // Comments and Whitespace Handling
  space += " " | "\t"
  newline = "\n"
  comment = "#" (~"\n" any)*
  multiLineComment = "/*" (~"*/" any)* "*/"
  space += comment | multiLineComment
}
