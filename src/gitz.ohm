Gitz {
  Program = Statement+                                         --program

  Statement =
      VarDecl                                                 --stmtVarDecl
    | ListDecl                                                --stmtListDecl
    | FunDecl                                                 --stmtFunDecl
    | Assignment                                              --stmtAssignment
    | FunCallStatement                                        --stmtFunCall
    | ReturnStmt                                              --stmtReturn
    | IfStmt                                                  --stmtIf
    | LoopStmt                                                --stmtLoop
    | TryStmt                                                 --stmtTry
    | BreakStmt                                               --stmtBreak
    | ContinueStmt                                            --stmtContinue
    | SayStmt                                                 --stmtSay

  FunCallStatement = FunCall ";"                              --funCallStmt
  BreakStmt        = "Break" ";"                              --breakStmt
  ContinueStmt     = "Skip" ";"                               --continueStmt
  SayStmt          = "say" "(" ExpList? ")" ";"               --sayStmt

  VarDecl  = "Make" id ":" (BasicType | ListType) Initialiser ";" --varDecl
  ListDecl = "Make" id ":" ListType Initialiser ";"               --listDecl

  Initialiser = "=" Exp                                        --init

  // Fixed: Made return type optional group more precise
  FunDecl =
      "Show" id Params ("->" Type)? Block                     --funDecl

  Params = "(" ParamList? ")"                                  --params
  ParamList = Param ("," Param)*                               --paramList
  Param  = id ":" Type                                         --param

  ReturnStmt = "give" Exp ";"                                  --returnStmt

  // Fixed: Simplified if-else syntax
  IfStmt =
      "When" Exp Block ("orWhen" Exp Block)* ("orElse" Block)? --ifStmt

  LoopStmt =
      "Keep" id "in" Exp Block                                 --loopForEach
    | "Keep" Exp Block                                         --loopWhile

  Assignment =
      (id | IndexedAccess) "=" Exp ";"                         --assignValid
    | IntLit "=" Exp ";"                                       --assignInvalid

  IndexedAccess = id "[" Exp "]"                               --index

  FunCall =
      id "(" ArgList ")"                                       --funCallArgs
    | id "(" ")"                                               --funCallNoArgs

  ArgList = Exp ("," Exp)*                                     --argList

  TryStmt = "Try" Block "Catch" id Block                       --tryStmt

  Block = "{" Statement* "}"                                   --block

  Exp = LogicalOrExp                                           --exp

  LogicalOrExp = LogicalAndExp ("or" LogicalAndExp)*           --lor
  LogicalAndExp = EqualityExp ("and" EqualityExp)*             --land
  EqualityExp = RelationalExp (EqualityOp RelationalExp)*      --eqExp
  EqualityOp = "==" | "!=" | "equal" | "notSame"               --eqOp
  RelationalExp = AdditiveExp (RelOp AdditiveExp)*             --relExp
  RelOp = "<" | ">" | "bigger" | "smaller" | "in"             --relOp
  AdditiveExp = MultiplicativeExp (AddOp MultiplicativeExp)*   --addExp
  AddOp = "plus" | "minus"                                     --addOp
  MultiplicativeExp = UnaryExp (MulOp UnaryExp)*               --mulExp
  MulOp = "times" | "over" | "mod"                             --mulOp

  UnaryExp = ("minus" | "not")? PrimaryExp                     --unary

  PrimaryExp =
      "(" Exp ")"                                              --parens
    | FunCall                                                  --primaryFunCall
    | IndexedAccess                                            --primaryIndex
    | id                                                       --primaryId
    | FloatLit                                                 --primaryFloat
    | IntLit                                                   --primaryInt
    | StringLit                                                --primaryString
    | ListExp                                                  --primaryList

  Type = BasicType | ListType                                  --type
  BasicType = "num" | "text" | "bool" | id                     --basicType
  ListType =
      "list" "[" Type "]"                                     --listTypeSquare
    | "list" "<" Type ">"                                     --listTypeAngle

  id = ~keyword letter alnum*                                  --identifier

  IntLit   = digit+                                            --intLit
  FloatLit =
      digit+ "." digit+ ExpPart?                               --floatFull
    | digit+ "." ExpPart?                                      --floatTrailingDot
    | "." digit+ ExpPart?                                      --floatLeadingDot

  ExpPart = "E" ("+" | "-")? digit+

  StringLit =
      "\"" Char* "\""                                         --stringClosed
    | "\"" Char*                                               --stringUnclosed

  ListExp = "[" ExpList? "]"                                  --listExp
  ExpList = Exp ("," Exp)*                                    --expList

  Char = NormalChar | EscapeSeq | unicodeEscape                --char
  NormalChar = ~Control ~"\\" ~"\"" any                       --normalChar
  EscapeSeq = "\\" ("n" | "t" | "\"" | "\\")                   --escapeSeq
  unicodeEscape = "\\u{" hexDigit+ "}"                         --unicodeEscape

  Control = "\x00".."\x1f" | "\x80".."\x9f"                   --control

  // Added missing keywords
  keyword = "Make" | "list" | "Show" | "When" | "Keep" | "orWhen"
          | "orElse" | "give" | "say" | "Break" | "Skip" | "Try"
          | "Catch" | "in"                                     --keyword

  space += " " | "\t" | comment | multiLineComment             --space
  newline = "\n"                                               --newline
  comment = "#" (~"\n" any)*                                   --comment
  multiLineComment = "/*" (~"*/" any)* "*/"                     --multiComment
}